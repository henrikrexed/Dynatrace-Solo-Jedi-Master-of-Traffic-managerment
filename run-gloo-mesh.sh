#!/usr/bin/env bash

export GLOO_MESH_VERSION=v2.4.1

# export ISTIO_IMAGE_REPO=us-docker.pkg.dev/gloo-mesh/istio-workshops
# export ISTIO_IMAGE_TAG=1.17.1-solo
# export ISTIO_VERSION=1.17.1
export REVISION=1-17

export DT_ENDPOINT=https://ikq13173.apps.dynatrace.com
# export DT_API_TOKEN=

export CLUSTER=mgmt-cluster
export CLUSTER_CONTEXT=$(kubectl config current-context)




kubectl create ns istio-gateways
kubectl label namespace istio-gateways istio.io/rev=1-17

istioctl install -f ./gloo-mesh/istio-values.yaml -y


kubectl create ns gloo-mesh-addons
kubectl label namespace gloo-mesh-addons istio.io/rev=1-17

cat ./gloo-mesh/gloomesh-values.yaml | sed 's@$DT_ENDPOINT@'"$DT_ENDPOINT"'@' | sed 's@$DT_API_TOKEN@'"$DT_API_TOKEN"'@' > ./gloo-mesh/gloomesh-values-AUTOGENERATED.yaml

meshctl install \
  --kubecontext $CLUSTER_CONTEXT \
  --license $GLOO_MESH_LICENSE_KEY \
  --set global.cluster=$CLUSTER \
  --chart-values-file ./gloo-mesh/gloomesh-values-AUTOGENERATED.yaml

kubectl create ns my-system1
kubectl label namespace my-system1 istio.io/rev=1-17

kubectl apply -f- <<EOF
apiVersion: admin.gloo.solo.io/v2
kind: KubernetesCluster
metadata:
  name: $CLUSTER
  namespace: gloo-mesh
spec:
  clusterDomain: cluster.local
EOF

kubectl apply -f- <<EOF
apiVersion: admin.gloo.solo.io/v2
kind: Workspace
metadata:
  name: gateways
  namespace: gloo-mesh
spec:
  workloadClusters:
  - name: $CLUSTER
    namespaces:
    - name: istio-gateways
    - name: gloo-mesh-addons
EOF

kubectl apply -f- <<EOF
apiVersion: admin.gloo.solo.io/v2
kind: WorkspaceSettings
metadata:
  name: gateways
  namespace: istio-gateways
spec:
  importFrom:
  - workspaces:
    - selector:
        allow_ingress: "true"
    resources:
    - kind: SERVICE
    - kind: ALL
      labels:
        expose: "true"
  exportTo:
  - workspaces:
    - selector:
        allow_ingress: "true"
    resources:
    - kind: SERVICE
EOF


kubectl apply -f- <<EOF
apiVersion: admin.gloo.solo.io/v2
kind: Workspace
metadata:
  name: my-system1
  namespace: gloo-mesh
  labels:
    allow_ingress: "true"
spec:
  workloadClusters:
  - name: $CLUSTER
    namespaces:
    - name: my-system1
EOF


kubectl apply -f- <<EOF
apiVersion: admin.gloo.solo.io/v2
kind: WorkspaceSettings
metadata:
  name: my-system1
  namespace: my-system1
spec:
  importFrom:
  - workspaces:
    - name: gateways
    resources:
    - kind: SERVICE
  exportTo:
  - workspaces:
    - name: gateways
    resources:
    - kind: ALL
      labels:
        expose: "true"
    - kind: SERVICE
      labels:
        app: app1
EOF

kubectl apply -f - <<EOF
apiVersion: networking.gloo.solo.io/v2
kind: VirtualGateway
metadata:
  name: north-south-gw
  namespace: istio-gateways
spec:
  workloads:
    - selector:
        labels:
          istio: ingressgateway
  listeners: 
    - http: {}
      port:
        number: 80
      allowedRouteTables:
        - host: '*'
EOF

kubectl apply -f - <<EOF
apiVersion: networking.gloo.solo.io/v2
kind: RouteTable
metadata:
  name: main
  namespace: istio-gateways
spec:
  hosts:
    - '*'
  virtualGateways:
    - name: north-south-gw
      namespace: istio-gateways
      cluster: $CLUSTER
  workloadSelectors: []
  http:
    - name: root
      matchers:
      - uri:
          prefix: /
      delegate:
        routeTables:
          - labels:
              expose: "true"
        sortMethod: ROUTE_SPECIFICITY
EOF

kubectl apply -f - <<EOF
apiVersion: networking.gloo.solo.io/v2
kind: RouteTable
metadata:
  name: my-system1
  namespace: my-system1
  labels:
    expose: "true"
spec:
  http:
    - name: my-system1
      matchers:
      - uri:
          prefix: /
      forwardTo:
        destinations:
          - ref:
              name: app1
              namespace: my-system1
            port:
              number: 9090
EOF


kubectl apply -f gloo-mesh/fake-service.yaml -n my-system1

export ENDPOINT_HTTP_GW_CLUSTER1=$(kubectl -n istio-gateways get svc -l istio=ingressgateway -o jsonpath='{.items[0].status.loadBalancer.ingress[0].*}'):80
echo "http://${ENDPOINT_HTTP_GW_CLUSTER1}/ui"